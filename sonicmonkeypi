#!/usr/bin/perl
# -----------------------------------------------------
# Soundmonkey for tiny Linuxes, preview version
# @diemastermonkey / @garyd
# Required: 
#   A FreeSound API key - get one here:
#     http://freesound.org/help/developers/ 
#   curl, play (sox) - or edit $Get and $Player
#   /bin/sh (forked)
#
# Optional:
#   Add keywords in keywords.txt
#   Edit output format in format.txt
#   Add banned sound authors to balist.txt!
#
# To do / missing features
#   Almost no error checking 
#   Cache expirey - it grows forever
#   Connect it to outside world
# -----------------------------------------------------
# Other fields of interest:
# bitdepth, samplerate 
# (URIs) analysis, analysis_stats, similar_sounds, images
# -----------------------------------------------------

# Default search keywords 
my @Keywords = split (/\s+/, 
  "sitar low-frequency circuit-bent thunder environmental");

# Settings
my $MinLen=20; my $MaxLen=111;             # Len limits of samples
my $PlayOverlap = 0.88;                   # pct overlap in sample play

my $Get="/usr/bin/curl --silent -o -";
my $Token=`cat token.txt`; chomp($Token); # No err check
my $Format=`cat format.txt`;              # No err check
my $Banlist = `cat banlist.txt`; chomp ($Banlist);
my $RunCount = -1;			  # -1 forever

my $Player="/usr/bin/play -V0 -q "
  ."\"cache/_SOUNDID_.ogg\" "             # Filename
  # ." --buffer 256 "    # Increase process buffer, default 8192
  ." rate -l"            # -m or -h or -l quality
  ." _SPEED_ "           # Speed effect if present
  # ." _OOPS_ "            # out-of-phase aka Karaoke, present or not 
  # ." contrast 0.85 "	 # Not useful? Look for norm?
  ." _REVERSE_ "         # either present or not (INSANE)
  ." _ECHOPARMS_ "
  ." repeat _REPEATS_ "      # Range 0 (one play) to N
  ." _BENDPARMS_ "          # Lo rez/parms at runtime
  ." fade _FIN_ _RIDE_ _FOUT_ "            # Fx...
  ." ";

my $Host="http://www.freesound.org/apiv2";
my $Search="search/text/?query=_KEYWORD_&token=$Token"
  ."&page_size=150"				     # Hardwired results size
  ."&filter=duration:\\[$MinLen\%20TO\%20$MaxLen\\]";# Ware escaping

my $Download="$Get \"_AUDIOURL_\" > cache/_SOUNDID_.ogg";
my $Info="sounds/_SOUNDID_/?token=$Token";
my $Touch="/usr/bin/touch ";	# filename wll be appended
my %Listings;                   # Search listing cache

# Get single-instance field from sound detail
# ------------------------------------------------------
sub fnField {
  my $field = shift (@_);
  my $data = shift (@_); 
  $match = "n/a";
  $match = $1 if (
    $data =~ /\"$field\"\:\s*\"*([^\\\"]+)\"*\,/
  );
  return ($match);
}

# Cache a set of keyword query results to disk
# ------------------------------------------------------
sub fnCacheWrite {
  my $word = shift (@_);
  my $data = shift (@_);
  open (OUT, ">cache/$word.cache")
    or die ("\nFatal: Can't write cache/$word.cache .\n");
  print (OUT $data);
  close (OUT);
}

# Read a cache
# ------------------------------------------------------
sub fnCacheRead {
  my $word = shift (@_);
  open (IN, "<cache/$word.cache")
    or die ("\nFatal: Can't read cache/$word.cache.\n");
  my $data = <IN>;
  close (IN);
  $ignored = `$Touch cache/$word.cache`; # For crude cache expiry
  return ($data);
}

# Sound player 
# ------------------------------------------------------
sub fnPlay {
  my $cmd = shift (@_);
  open (PLAY, "|/bin/sh|")
    or die ("\nFatal: Can't open player with $Player\n");
  print (PLAY "$cmd \&");
  close (PLAY);
}

# Mainline
# ------------------------------------------------------

# Append contents of 'keywords.txt' if exists
if (-r "keywords.txt") { 
  $raw = `cat keywords.txt`; 	# Brutal
  push (@Keywords, split (/\n+|\s+|\,/, $raw));
}

# First lone number if any in argv assumed to be runcount
if (grep (/\d/, @ARGV)) {
  $RunCount = shift (@ARGV);
}

# Append keywords from cmd line if any
if (grep(s/\=//, @ARGV)) { 
  @Keywords = @ARGV;       # Override all with =keyword
} else {                   # Else append all (or none)
  push (@Keywords, shift (@ARGV)) if (@ARGV);
}

# Make cache dir if no exist
unless (-d "cache") { `mkdir cache` };

# Loop either forever, or till RunCount exhausted
while ($RunCount < 0 or $RunCount > 0) {
  $RunCount--;

  # Choose a keyword search
  $KeywordIndex = int(rand(@Keywords));
  $Keyword = @Keywords[$KeywordIndex];
  $Query = "$Host/$Search";
  $Query =~ s/_KEYWORD_/$Keyword/g;

  # Use cached results if found
  if (-r "cache/$Keyword.cache") {
    $WasCached = 1;
    $Listing = fnCacheRead($Keyword); 
  } else {
    $WasCached = 0;
    $Listing = `$Get \"$Query\"`; 
    # $Listings{$Keyword} = $Listing;     # Memory cache
    fnCacheWrite ($Keyword, $Listing);  # Add to cache
  }

  # Grok search listing
  $Sounds = $1 if ($Listing =~ /\"count\"\:\s*(\d+)\,/);
  @ListingFields = split (/\,/, $Listing);
  @SoundIDs = grep (/\"id\"\:\s*\d+/, @ListingFields); 
  @SoundIDs = grep (s/\D+//g, @SoundIDs);

  # Pick a sound ID
  $Selected = @SoundIDs[int(rand(scalar(@SoundIDs)))]; 

  # Use cached sound metadata if found
  if (-r "cache/$Selected-data.cache") {
    $SoundMeta = fnCacheRead("$Selected\-data"); 
    $SoundCached = "|";		# Indicate was cached
  } else {
    # Get the sound metadata record
    $Query = "$Host/$Info";
    $Query =~ s/_SOUNDID_/$Selected/g;
    $SoundMeta = `$Get \"$Query\"`; 
    fnCacheWrite ("$Selected\-data", $SoundMeta); # Add to cache 
    $SoundCached = ">";
  }

  # HQ $SoundPreview = fnField ("preview-hq-ogg", $SoundMeta);
  $SoundPreview = fnField ("preview-lq-ogg", $SoundMeta);
  $SoundAuthor = fnField ("username", $SoundMeta);
  $SoundName = fnField ("name", $SoundMeta);
  $SoundDesc = fnField ("description", $SoundMeta);
  $SoundLength = fnField ("duration", $SoundMeta);
  $SoundRating = fnField ("avg_rating", $SoundMeta);
  $SoundLicense = fnField ("license", $SoundMeta);
  $SoundURL = fnField ("url", $SoundMeta);

  # New: Skip completely if author or ID on banlist
  # WARNING, a silent eternal loop possible here! FIX !
  if ($Banlist =~ /$SoundAuthor/i or $Banlist =~ /$Selected/i) { 
    print ("...skipped $SoundAuthor"); # trails
    next;  # Skip rest of loop
  }

  # Info
  # Rating: $SoundRating");
  # print ("\nAudio  : $SoundPreview");
  print ("\n");   # Breaks trailing display
  printf ($Format, 
    $Selected,	  # id
    $SoundAuthor, # author
    $SoundLength, # len
    $SoundCached, # cache indicator
    $Keyword,     # keyword
    $SoundName,   # title
    $SoundLicense,# license
    $SoundURL,    # URL
    $SoundDesc    # desc
  ); 

  # Crude audio cache
  if (-r "cache/$Selected.ogg") {
    # To do: expire old caches
  } else {        # BruteCache (tm)
    $Query = $Download;
    $Query =~ s/_AUDIOURL_/$SoundPreview/g;
    $Query =~ s/_SOUNDID_/$Selected/g;
    # print ("\nBruteCaching(tm)...\r");
    $SoundMeta = `$Query`; 
  }

  # Kludge special effects parms
  $FadeIn = $SoundLength * 0.20;
  $FadeOut = $SoundLength * 0.25;
  $FadeIn = 10 if ($FadeIn > 10);
  $FadeOut = 10 if ($FadeOut > 10);
  $FadeRide = 0; # Makes ride all remaining len
  # $Pitch = -1 * int(rand(1000)); # Hardwired pitch-down range

  # Handle echo or none Update: actually is delay
  $EchoParms = " ";
  if (int(rand(5)) == 0) {
    $EchoTime = 0.5 + rand(6.6);
    # $EchoParms = " delay 0 $EchoTime ";   # Only 2nd channel delayed, is faster
    $EchoParms = " delay $EchoTime ";   # Only 2nd channel delayed, is faster
  }

  # Repeats: Shorter samples repeat more, max 45s
  $Repeats = 0;
  $Repeats += int(rand(3)) if ($SoundLength < 41); # If larger, 0 

  # Apply bends to _BENDPARMS_
  $BendParms = "";
  $BendTemp = "";
  $Bends = int(rand(3));
  if ($Bends) {$Bends = 1 if ($SoundLength < 61);} # No multibend short samples
  $sections = $SoundLength / 10;
  for ($i=0; $i < $Bends ; $i++) {
    $BendDelay = $sections * ($i + 1);
    $BendDelay *= 1 + rand(2);	# Could up to doulble
    # Pitch bend. To do: Base on sample tone
    $BendTime = $sections;      # Boring but safe?
    $BendCents = -1 * int(rand(333));
    $BendCents *= -1 if (int(rand(2))); # maybe invert
    $BendTemp .= "$BendDelay,$BendCents,$BendTime ";
  }
  if ($Bends) {
    $BendParms = "bend -f 10 -o 4 $BendTemp";
  }

  # Rarely, enable reverse play
  $Reverse = "";   # dumb
  if (int(rand(5)) == 0) {
    $Reverse = "reverse";
  }

  # Rarely, speed effect (slow only)
  $Speed = "";   # dumb
  if (int(rand(9)) == 0) {
    $s = rand(0.6) + 0.38;  # Range 0.4 - 1.0
    $Speed = " speed $s ";
  }

  # Play the preview and wait
  # print ("\R$Repeats B$Bends Fi$FadeIn Eg$EchoGain \n"); # Debug
  $Play = $Player; 
  $Play =~ s/_SOUNDID_/$Selected/g;
  $Play =~ s/_FIN_/$FadeIn/g;
  $Play =~ s/_RIDE_/$FadeRide/g;
  $Play =~ s/_FOUT_/$FadeOut/g;
  $Play =~ s/_SPEED_/$Speed/g; 
  $Play =~ s/_OOPS_/$Oops/g; 
  $Play =~ s/_REVERSE_/$Reverse/g;   # Totally insane
  $Play =~ s/_ECHOPARMS_/$EchoParms/g;
  $Play =~ s/_BENDPARMS_/$BendParms/g;
  $Play =~ s/_REPEATS_/$Repeats/g;

  # Play via shell pipe
  print ("\r                     \rPlaying... \n"); # Pre-erases
  fnPlay ($Play);

  # Wait for 1/Xth length of the audio
  # print ("\rResting...\n");
  sleep (int ($SoundLength * $PlayOverlap));
  print ("\rChoosing...");
}

# RunCount used up 
print ("\nEnding (RunCount 0).");
# fin
