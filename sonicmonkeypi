#!/usr/bin/perl
# Soundmonkey for tiny Linuxes
# HIGHLY recommended: Register for your own API key at Freesound.org
# Required: curl, play (sox) - or edit $Get and $Player
# Optional: Edit keyword list (see @Keywords)
# Hint: Run several instances
# To do: Get/track paged results

# Settings
my @Keywords = split (/ /, 
  "drone ambiance atmosphere background background-sound "
  ."airconditioner hum rumble environment environmental "
  ."street audience sub-bass"
  ."forest ocean outside jungle festival carnival "
  ."tv television radio "
  ."opera symphony tuning speech "
  ."german russian italian spanish french tibetan british indian "
);
# Append keywords from cmd line if any
push (@Keywords, shift (@ARGV)) if (@ARGV);

my $Get="/usr/bin/curl --silent -o -";
# Mod: Fade in/ride/out time tokens
my $Token="012e5b385463f30b2fd860b0692ea631fa5a941f";
my $Player="/usr/bin/play -V1 -q \"cache/_SOUNDID_.ogg\""
	." fade _FIN_ _RIDE_ _FOUT_ norm 1.0";
my $Host="http://www.freesound.org/apiv2";
my $Search="search/text/?query=_KEYWORD_&token=$Token";
my $Download="$Get \"_AUDIOURL_\" > cache/_SOUNDID_.ogg";
my $Info="sounds/_SOUNDID_/?token=$Token";
my %Listings;  # Search listing cache

# Get single-instance field from sound detail
# ------------------------------------------------------
sub fnField {
  $field = shift (@_);
  $data = shift (@_); 
  $match = "n/a";
  $match = $1 if (
    $data =~ /\"$field\"\:\s\"*([^\\\"]+)\"*\,/
  );
  return ($match);
}

# Cache a set of keyword query results to disk
# ------------------------------------------------------
sub fnCacheWrite {
  my $word = shift (@_);
  my $data = shift (@_);
  open (OUT, ">cache/$word.cache")
    or die ("\nFatal: Can't write cache/$word.cache .\n");
  print (OUT $data);
  close (OUT);
}

# Read a cache
# ------------------------------------------------------
sub fnCacheRead {
  my $word = shift (@_);
  open (IN, "<cache/$word.cache")
    or die ("\nFatal: Can't read cache/$word.cache.\n");
  my $data = <IN>;
  close (IN);
  return ($data);
}

# Mainline
# ------------------------------------------------------

# Handle any command line mods


while (true) {

  # Choose a keyword search
  $KeywordIndex = int(rand(@Keywords));
  $Keyword = @Keywords[$KeywordIndex];
  $Query = "$Host/$Search";
  $Query =~ s/_KEYWORD_/$Keyword/g;

  # Prefer cached results
  # if ($Listings{$Keyword}) {  # Old mem cache
  if (-r "cache/$Keyword.cache") {	# Cache exists on disk
    $WasCached = 1;
    $Listing = fnCacheRead($Keyword); 
  } else {
    $WasCached = 0;
    $Listing = `$Get \"$Query\"`; 
    $Listings{$Keyword} = $Listing; # Memory cache
    fnCacheWrite ($Keyword, $Listing); 
  }

  # Get search listing
  $Sounds = $1 if ($Listing =~ /\"count\"\:\s*(\d+)\,/);
  @ListingFields = split (/\,/, $Listing);
  @SoundIDs = grep (/\"id\"\:\s\d+/, @ListingFields); 
  @SoundIDs = grep (s/\D+//g, @SoundIDs);

  # Pick a sound ID
  $Selected = @SoundIDs[int(rand(scalar(@SoundIDs)))]; 

  # Get the sound metadata record
  $Query = "$Host/$Info";
  $Query =~ s/_SOUNDID_/$Selected/g;
  $SoundMeta = `$Get \"$Query\"`; 

  $SoundPreview = fnField ("preview-hq-ogg", $SoundMeta);
  $SoundAuthor = fnField ("username", $SoundMeta);
  $SoundName = fnField ("name", $SoundMeta);
  $SoundDesc = fnField ("description", $SoundMeta);
  $SoundLength = fnField ("duration", $SoundMeta);
  $SoundRating = fnField ("avg_rating", $SoundMeta);
  $SoundLicense = fnField ("license", $SoundMeta);
  $SoundURL = fnField ("url", $SoundMeta);

  # Info
  print ("\n"."-" x 48);
  print ("\nKeyword: $Keyword (".scalar(@SoundIDs)." found)");
  print (" (cached)") if ($WasCached);
  print ("\nID     : $Selected");
  print (" (cached)") if (-r "cache/$Selected.ogg");
  print ("\nName   : $SoundName");
  print ("\nAuthor : $SoundAuthor");
  print ("\nInfo   : $SoundDesc");
  print ("\nLength : $SoundLength \t Rating: $SoundRating");
  print ("\nLicense: $SoundLicense");
  print ("\nURL    : $SoundURL");
  # print ("\nAudio  : $SoundPreview");
  print ("\n"."-" x 48);

  # New: Handle audio cache
  if (-r "cache/$Selected.ogg") {
    # To do: expire old caches
    print ("\nNote: Cache exists");
  } else {
    # Brutalcache (tm)
    $Query = $Download;
    $Query =~ s/_AUDIOURL_/$SoundPreview/g;
    $Query =~ s/_SOUNDID_/$Selected/g;
    print ("\nBrutalCaching(tm)...\r");
    $SoundMeta = `$Query`; 
  }

  # Kludge 
  $FadeIn = $SoundLength / 10;
  $FadeOut = $FadeIn;
  $FadeRide = $FadeIn * 8;

  # Play the preview and wait
  $Play = $Player; 
  $Play =~ s/_SOUNDID_/$Selected/g;
  $Play =~ s/_FIN_/$FadeIn/g;
  $Play =~ s/_RIDE_/$FadeRide/g;
  $Play =~ s/_FOUT_/$FadeOut/g;
  print ("\r                    \r");
  print ("\rPlaying...\r");
  $Ignored = `$Play`;
  print ("\r                    \r");
  print ("\rChoosing...\r");
}
